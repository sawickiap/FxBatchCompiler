using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Threading;

namespace FXBC
{
    // This structure represents input and output data for "standard error handling thread"
    class FxcLaunchThreadData
    {
        // ==== INPUT ====
        // Reference to running compiler process
        public Process m_Process;

        // ==== OUTPUT ====
        // Output generated by the compiler on its standard error output
        public string m_StandardErrorData;

        public FxcLaunchThreadData(Process Process)
        {
            m_Process = Process;
        }
    }

    // Represents ability to run the FX compiler
    static class Fxc
    {
        // Run FXC from given path, with given working directory (optional, can be null)
        // and parameters (optional, can be null), wait for termination and return output.
        // On error, returns appropriate error message - does not throw exceptions.
        // Returns true if execution succeeded.
        public static bool Run(out string Output, string FxcPath, string Parameters, string WorkingDirectory)
        {
            try
            {
                System.Diagnostics.Process Process = new System.Diagnostics.Process();

                Process.StartInfo.UseShellExecute = false;
                Process.StartInfo.RedirectStandardOutput = true;
                Process.StartInfo.RedirectStandardError = true;
                Process.StartInfo.CreateNoWindow = true;

                Process.StartInfo.FileName = FxcPath;
                if (Parameters != null && Parameters.Length > 0)
                    Process.StartInfo.Arguments = Parameters;
                if (WorkingDirectory != null && WorkingDirectory.Length > 0)
                    Process.StartInfo.WorkingDirectory = WorkingDirectory;

                Process.Start();

                FxcLaunchThreadData Data = new FxcLaunchThreadData(Process);
                Thread t = new Thread(new ParameterizedThreadStart(StandardErrorHandlingThread));
                t.Start(Data);

                Output = Process.StandardOutput.ReadToEnd();
                Process.WaitForExit();

                t.Join();
                if (Data.m_StandardErrorData.Length > 0)
                    Output += Data.m_StandardErrorData;

                return true;
            }
            catch (Exception Err)
            {
                Output = "================ ERROR ================\r\n\r\n" + Err.Message;
                return false;
            }
        }

        // Unfortunately, there have to be additional thread for each running compiler
        // to handle its error output, as both standard output and error output cannot
        // be read synchronously by one thread as it leads to deadlock.
        private static void StandardErrorHandlingThread(Object Obj)
        {
            FxcLaunchThreadData Data = (FxcLaunchThreadData)Obj;

            Data.m_StandardErrorData = Data.m_Process.StandardError.ReadToEnd();
        }
    }
}
